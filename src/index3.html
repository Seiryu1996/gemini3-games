<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>NEON BUILDER AR</title>
    <style>
        /* --- Y2K / CYBER DESIGN --- */
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Courier New', Courier, monospace; }
        
        #canvas-container { position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; z-index: 2; }
        #video-container { position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; z-index: 1; object-fit: cover; transform: scaleX(-1); /* 自撮り用反転 */ }

        /* UI Overlay */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10; pointer-events: none;
            display: flex; flex-direction: column; justify-content: space-between;
        }

        .hud-top {
            padding: 20px; display: flex; justify-content: space-between;
            text-shadow: 0 0 5px #0ff; color: #0ff; font-weight: bold;
        }
        
        .hud-bottom {
            padding: 20px; text-align: center;
            color: #f0f; text-shadow: 0 0 5px #f0f;
        }

        /* Loading Screen */
        #loading {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; color: #0f0; z-index: 100;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
        }
        .loader {
            border: 4px solid #000; border-top: 4px solid #0f0; border-radius: 50%;
            width: 40px; height: 40px; animation: spin 1s linear infinite; margin-bottom: 20px;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* Start Button */
        #start-btn {
            padding: 15px 40px; background: transparent; border: 2px solid #0f0; color: #0f0;
            font-size: 18px; cursor: pointer; display: none; pointer-events: auto;
            box-shadow: 0 0 10px #0f0, inset 0 0 10px #0f0;
            text-transform: uppercase; letter-spacing: 2px;
        }
        #start-btn:hover { background: #0f0; color: #000; }

        .scan-line {
            width: 100%; height: 2px; background: rgba(0, 255, 255, 0.3);
            position: absolute; animation: scan 3s linear infinite; top: 0;
        }
        @keyframes scan { 0% { top: 0%; } 100% { top: 100%; } }

    </style>
</head>
<body>

    <!-- Camera Feed -->
    <video id="webcam" autoplay playsinline muted></video>

    <!-- 3D Canvas -->
    <div id="canvas-container"></div>

    <!-- UI -->
    <div id="ui-layer">
        <div class="hud-top">
            <div>REC ●</div>
            <div>FPS: <span id="fps">60</span></div>
        </div>
        <div class="scan-line"></div>
        <div class="hud-bottom">
            <p>PINCH: BUILD / FIST: BREAK</p>
        </div>
    </div>

    <!-- Loading / Start -->
    <div id="loading">
        <div class="loader"></div>
        <div id="status-text">INITIALIZING SYSTEM...</div>
        <button id="start-btn">START HACKING</button>
    </div>

    <!-- Libraries (ES Modules) -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { FilesetResolver, HandLandmarker } from '@mediapipe/tasks-vision';

        // --- Configuration ---
        const videoElement = document.getElementById('webcam');
        const canvasContainer = document.getElementById('canvas-container');
        const loadingScreen = document.getElementById('loading');
        const statusText = document.getElementById('status-text');
        const startBtn = document.getElementById('start-btn');
        const isMobile = /Android|iPhone|iPad|iPod/i.test(navigator.userAgent);
        let handLandmarker = undefined;
        let webcamRunning = false;
        
        // --- Three.js Scene Setup ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 2; // カメラを少し引く

        const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        canvasContainer.appendChild(renderer.domElement);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xff00ff, 1.5); // Pink light
        directionalLight.position.set(2, 2, 5);
        scene.add(directionalLight);

        // Objects List
        const blocks = [];
        const particles = [];

        // Cursor (Hand indicator)
        const cursorGeo = new THREE.IcosahedronGeometry(0.05, 0);
        const cursorMat = new THREE.MeshBasicMaterial({ color: 0x00ffff, wireframe: true });
        const cursor = new THREE.Mesh(cursorGeo, cursorMat);
        scene.add(cursor);
        cursor.visible = false;

        // --- MediaPipe Setup ---
        const createHandLandmarker = async () => {
            const vision = await FilesetResolver.forVisionTasks(
                "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm"
            );
            handLandmarker = await HandLandmarker.createFromOptions(vision, {
                baseOptions: {
                    modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`,
                    delegate: "GPU"
                },
                runningMode: "VIDEO",
                numHands: 2
            });
            statusText.innerText = "SYSTEM READY";
            document.querySelector('.loader').style.display = 'none';
            startBtn.style.display = 'block';
        };

        createHandLandmarker();

        // --- Game Logic ---
        let lastVideoTime = -1;
        let isPinching = false;
        let pinchCooldown = 0;

        // Start Camera
        startBtn.addEventListener('click', async () => {
            if (!handLandmarker) return;
            loadingScreen.style.display = 'none';

            const preferredFacing = isMobile ? "environment" : "user";
            const constraintsList = [
                { video: { facingMode: { exact: preferredFacing }, width: { ideal: 1280 }, height: { ideal: 720 } } },
                { video: { facingMode: preferredFacing, width: { ideal: 1280 }, height: { ideal: 720 } } },
                { video: { facingMode: "user", width: { ideal: 1280 }, height: { ideal: 720 } } }
            ];

            let lastError;
            for (const constraints of constraintsList) {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia(constraints);
                    videoElement.srcObject = stream;
                    videoElement.addEventListener("loadeddata", predictWebcam, { once: true });
                    webcamRunning = true;
                    return;
                } catch (err) {
                    lastError = err;
                }
            }

            console.error(lastError);
            alert("カメラの許可が必要です / Camera permission needed");
        });

        async function predictWebcam() {
            if(videoElement.currentTime !== lastVideoTime) {
                lastVideoTime = videoElement.currentTime;
                const startTimeMs = performance.now();
                
                if (handLandmarker) {
                    const results = handLandmarker.detectForVideo(videoElement, startTimeMs);
                    handleHandInteraction(results);
                }
            }
            
            updateGameObjects();
            renderer.render(scene, camera);
            window.requestAnimationFrame(predictWebcam);
        }

        function handleHandInteraction(results) {
            if (results.landmarks.length > 0) {
                cursor.visible = true;
                
                // 最初の検出された手を使用
                const landmarks = results.landmarks[0];
                
                // 座標変換 (MediaPipe[0-1] -> Three.js World)
                // xは反転させる（ミラーリングのため）
                const x = (1 - landmarks[8].x) * 2 - 1; // 人差し指の先
                const y = -(landmarks[8].y * 2 - 1);
                
                // カーソル位置の更新 (画面上の平面Z=0あたりに投影)
                // アスペクト比補正
                const aspect = window.innerWidth / window.innerHeight;
                const depth = 1.5; // カメラからの距離
                
                // 簡易的な投影計算
                cursor.position.set(x * depth * aspect, y * depth, 0);

                // --- アクション判定 ---
                
                // 1. ピンチ判定 (親指[4]と人差し指[8]の距離)
                const thumbTip = landmarks[4];
                const indexTip = landmarks[8];
                const distance = Math.hypot(thumbTip.x - indexTip.x, thumbTip.y - indexTip.y);

                if (distance < 0.05) { // ピンチ閾値
                    if (!isPinching && pinchCooldown <= 0) {
                        createBlock(cursor.position);
                        isPinching = true;
                        pinchCooldown = 15; // フレーム数でクールダウン
                        cursor.material.color.setHex(0xff00ff); // 色変更
                    }
                } else {
                    isPinching = false;
                    cursor.material.color.setHex(0x00ffff);
                }

                // 2. 破壊判定 (カーソルがブロックに触れたら)
                // グーの判定は簡易的に全指が近いかどうかでも良いが、
                // ここではシンプルに「カーソルがブロックに重なったら」判定にする
                checkCollision(cursor.position);

            } else {
                cursor.visible = false;
            }

            if (pinchCooldown > 0) pinchCooldown--;
        }

        function createBlock(pos) {
            // グリッドスナップ
            const gridSize = 0.2;
            const snapX = Math.round(pos.x / gridSize) * gridSize;
            const snapY = Math.round(pos.y / gridSize) * gridSize;
            
            // ネオンカラーの生成
            const colors = [0x00ffff, 0xff00ff, 0xffff00, 0x00ff00];
            const randomColor = colors[Math.floor(Math.random() * colors.length)];

            const geometry = new THREE.BoxGeometry(0.15, 0.15, 0.15);
            const material = new THREE.MeshStandardMaterial({ 
                color: randomColor, 
                roughness: 0.2,
                metalness: 0.8,
                transparent: true,
                opacity: 0.9
            });
            const cube = new THREE.Mesh(geometry, material);
            
            // ワイヤーフレーム（サイバー感を出すため）
            const edges = new THREE.EdgesGeometry(geometry);
            const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0xffffff }));
            cube.add(line);

            cube.position.set(snapX, snapY, 0);
            
            // 出現アニメーション用データ
            cube.userData = { scale: 0, targetScale: 1, life: 1000 };
            cube.scale.set(0,0,0);

            scene.add(cube);
            blocks.push(cube);
        }

        function checkCollision(handPos) {
            // 単純な距離判定
            for (let i = blocks.length - 1; i >= 0; i--) {
                const block = blocks[i];
                const dist = handPos.distanceTo(block.position);
                
                // ブロックの近くで、かつピンチしていない（破壊モード）時
                if (dist < 0.15 && !isPinching) {
                    destroyBlock(block, i);
                }
            }
        }

        function destroyBlock(block, index) {
            // パーティクル生成
            createParticles(block.position, block.material.color);
            
            scene.remove(block);
            blocks.splice(index, 1);
        }

        function createParticles(pos, color) {
            for(let i=0; i<8; i++) {
                const geo = new THREE.PlaneGeometry(0.02, 0.02);
                const mat = new THREE.MeshBasicMaterial({ color: color, side: THREE.DoubleSide });
                const p = new THREE.Mesh(geo, mat);
                p.position.copy(pos);
                // ランダムな方向に散らす
                p.userData = { 
                    velocity: new THREE.Vector3(
                        (Math.random() - 0.5) * 0.1,
                        (Math.random() - 0.5) * 0.1,
                        (Math.random() - 0.5) * 0.1
                    ),
                    life: 60
                };
                scene.add(p);
                particles.push(p);
            }
        }

        function updateGameObjects() {
            // ブロックのアニメーション
            blocks.forEach(b => {
                b.rotation.x += 0.01;
                b.rotation.y += 0.01;
                if(b.userData.scale < b.userData.targetScale) {
                    b.userData.scale += 0.1;
                    b.scale.setScalar(b.userData.scale);
                }
            });

            // パーティクルの更新
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.position.add(p.userData.velocity);
                p.userData.life--;
                p.scale.setScalar(p.userData.life / 60);
                
                if (p.userData.life <= 0) {
                    scene.remove(p);
                    particles.splice(i, 1);
                }
            }
            
            // FPS更新 (簡易)
            document.getElementById('fps').innerText = Math.round(1000 / (performance.now() - lastVideoTime) * 10) || 60;
        }

        // リサイズ対応
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
