<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>CYBER DIVE AR</title>
    <style>
        /* --- VAPORWAVE / CYBERPUNK UI --- */
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Courier New', Courier, monospace; }
        
        /* Camera Background */
        #webcam {
            position: fixed; top: 0; left: 0; min-width: 100%; min-height: 100%;
            width: auto; height: auto; z-index: 1; object-fit: cover;
            filter: contrast(1.2) brightness(0.8); /* 映像を少し暗くしてUIを目立たせる */
        }

        #canvas-container { position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; z-index: 2; }

        /* HUD */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10; pointer-events: none;
            display: flex; flex-direction: column; justify-content: space-between;
        }

        .hud-top {
            padding: 20px; display: flex; justify-content: space-between;
            color: #fff; font-weight: bold; text-shadow: 2px 2px 0 #f0f;
        }
        .hud-value { font-size: 24px; color: #0ff; }
        .hud-label { font-size: 12px; color: #fff; opacity: 0.8; }

        .hud-center {
            position: absolute; top: 40%; width: 100%; text-align: center;
            font-size: 60px; font-weight: 900; font-style: italic;
            color: #ff0; text-shadow: 4px 4px 0 #f00;
            display: none; transform: skew(-10deg);
        }

        /* Danger Overlay */
        #damage-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle, transparent 50%, rgba(255,0,0,0.8) 100%);
            opacity: 0; transition: opacity 0.1s; pointer-events: none; z-index: 5;
        }

        /* Screens */
        .screen {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.95); z-index: 100;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            color: #0ff;
        }

        h1 { 
            font-size: 40px; margin-bottom: 10px; text-align: center;
            background: linear-gradient(90deg, #0ff, #f0f); -webkit-background-clip: text; -webkit-text-fill-color: transparent;
        }

        .btn {
            margin-top: 30px; padding: 15px 40px;
            background: transparent; border: 2px solid #0ff; color: #0ff;
            font-size: 18px; cursor: pointer; pointer-events: auto;
            box-shadow: 0 0 15px #0ff; transition: 0.2s;
        }
        .btn:active { background: #0ff; color: #000; }
        
        .hidden { display: none !important; }

        /* Tilt Guide */
        .tilt-guide {
            width: 100px; height: 60px; border: 2px solid #666; border-radius: 10px; margin-top: 20px;
            position: relative; animation: tilt-anim 2s infinite ease-in-out;
        }
        .tilt-guide::after {
            content: ''; position: absolute; top: 50%; left: 50%; width: 80%; height: 2px;
            background: #666; transform: translate(-50%, -50%);
        }
        @keyframes tilt-anim { 
            0% { transform: rotate(0deg); } 
            25% { transform: rotate(15deg); } 
            75% { transform: rotate(-15deg); } 
            100% { transform: rotate(0deg); } 
        }

    </style>
</head>
<body>

    <video id="webcam" autoplay playsinline muted></video>
    <div id="damage-overlay"></div>
    <div id="canvas-container"></div>

    <!-- HUD -->
    <div id="ui-layer" class="hidden">
        <div class="hud-top">
            <div>
                <div class="hud-label">TIME</div>
                <div class="hud-value" id="score">0.00</div>
            </div>
            <div style="text-align: right;">
                <div class="hud-label">LEVEL</div>
                <div class="hud-value" id="level">1</div>
            </div>
        </div>
        <div class="hud-center" id="level-msg">SPEED UP!!</div>
    </div>

    <!-- Start Screen -->
    <div id="start-screen" class="screen">
        <h1>CYBER<br>DIVE</h1>
        <p>TILT YOUR PHONE TO DODGE</p>
        <div class="tilt-guide"></div>
        <p style="font-size:12px; color:#666; margin-top:20px;">REQUIRES MOTION SENSORS</p>
        
        <!-- iOS 13+ Needs Permission -->
        <button id="perm-btn" class="btn">ALLOW SENSOR & START</button>
    </div>

    <!-- Game Over Screen -->
    <div id="game-over-screen" class="screen hidden">
        <h1 style="color:#f00; -webkit-text-fill-color: #f00;">CRASHED</h1>
        <p>SURVIVAL TIME</p>
        <p style="font-size: 30px; color:#fff;" id="final-score">0.00</p>
        <button id="retry-btn" class="btn">RETRY DIVE</button>
    </div>

    <!-- THREE.JS -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // --- Game Config ---
        const CONFIG = {
            baseSpeed: 0.3,
            speedMultiplier: 0.05,
            spawnRateBase: 40, // frames
            levelDuration: 10, // seconds per level
            tunnelRadius: 6,
            playerSensibility: 0.08
        };

        let state = {
            isPlaying: false,
            timeElapsed: 0,
            level: 1,
            speed: CONFIG.baseSpeed,
            spawnTimer: 0
        };

        // Gyro Data
        let input = { x: 0, y: 0 }; // Normalized -1 to 1

        // DOM
        const scoreEl = document.getElementById('score');
        const levelEl = document.getElementById('level');
        const levelMsg = document.getElementById('level-msg');
        const startScreen = document.getElementById('start-screen');
        const gameOverScreen = document.getElementById('game-over-screen');
        const damageOverlay = document.getElementById('damage-overlay');
        const finalScoreEl = document.getElementById('final-score');
        const permBtn = document.getElementById('perm-btn');

        // --- Three.js Setup ---
        const scene = new THREE.Scene();
        // Camera simulates player head
        const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 100);
        
        const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xff00ff, 2);
        dirLight.position.set(0, 10, 5);
        scene.add(dirLight);

        // Player Ship (Visual indicator only, actually we move camera)
        // We place a cockpit frame around the camera
        const cockpitGroup = new THREE.Group();
        camera.add(cockpitGroup);
        scene.add(camera);

        // Tunnel / Grid Floor (Infinite scrolling effect)
        const gridHelper = new THREE.GridHelper(40, 40, 0x00ffff, 0x220022);
        gridHelper.position.y = -3;
        scene.add(gridHelper);
        const ceilingHelper = new THREE.GridHelper(40, 40, 0xff00ff, 0x220000);
        ceilingHelper.position.y = 3;
        scene.add(ceilingHelper);
        
        // Speed Lines (Stars)
        const starGeo = new THREE.BufferGeometry();
        const starCount = 500;
        const starPos = new Float32Array(starCount * 3);
        for(let i=0; i<starCount*3; i++) {
            starPos[i] = (Math.random() - 0.5) * 50;
        }
        starGeo.setAttribute('position', new THREE.BufferAttribute(starPos, 3));
        const starMat = new THREE.PointsMaterial({color: 0xffffff, size: 0.1});
        const stars = new THREE.Points(starGeo, starMat);
        scene.add(stars);

        let obstacles = [];

        // --- Logic ---

        // iOS Permission & Event Listener
        const setupGyro = async () => {
            // Check if iOS 13+
            if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                try {
                    const permission = await DeviceOrientationEvent.requestPermission();
                    if (permission === 'granted') {
                        window.addEventListener('deviceorientation', handleOrientation);
                        startGame();
                    } else {
                        alert("Permission denied. Game cannot run.");
                    }
                } catch (e) {
                    console.error(e);
                    // Non-secure context or other error, try starting anyway
                    startGame();
                }
            } else {
                // Non-iOS 13+ devices
                window.addEventListener('deviceorientation', handleOrientation);
                startGame();
            }
        };

        function handleOrientation(event) {
            // Beta: Front/Back tilt (-180 to 180). We use -30 to 30 roughly.
            // Gamma: Left/Right tilt (-90 to 90). We use -30 to 30.
            
            // Adjust based on initial holding position if needed, but here we assume relatively upright
            let x = event.gamma; // Left/Right
            let y = event.beta;  // Up/Down
            
            // Clamp and Normalize (-1 to 1)
            if(!x) x = 0; 
            if(!y) y = 0;

            // Portrait mode handling
            // 45 degrees tilt = max speed
            input.x = Math.max(-1, Math.min(1, x / 30)); 
            input.y = Math.max(-1, Math.min(1, (y - 45) / 30)); // 45deg is neutral holding angle
        }

        function startGame() {
            startCamera();
            resetGame();
            startScreen.classList.add('hidden');
            document.getElementById('ui-layer').classList.remove('hidden');
            gameOverScreen.classList.add('hidden');
            animate();
        }

        async function startCamera() {
            const video = document.getElementById('webcam');
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    video: { facingMode: "environment" } 
                });
                video.srcObject = stream;
            } catch (err) {
                console.log("Camera failed or not present (Desktop?)");
            }
        }

        function resetGame() {
            state = {
                isPlaying: true,
                timeElapsed: 0,
                level: 1,
                speed: CONFIG.baseSpeed,
                spawnTimer: 0
            };
            
            // Clear obstacles
            obstacles.forEach(o => scene.remove(o));
            obstacles = [];
            
            camera.position.set(0, 0, 0);
            camera.rotation.set(0, 0, 0);
            
            scoreEl.innerText = "0.00";
            levelEl.innerText = "1";
        }

        function spawnObstacle() {
            // Geometry
            const type = Math.random();
            let geo, color;
            
            if(type > 0.5) {
                // Wall
                geo = new THREE.BoxGeometry(2, 8, 1);
                color = 0xff0000;
            } else {
                // Block
                geo = new THREE.BoxGeometry(3, 3, 3);
                color = 0xff5500;
            }

            const mat = new THREE.MeshBasicMaterial({ color: color, wireframe: true });
            const mesh = new THREE.Mesh(geo, mat);
            
            // Neon Glow inside
            const coreGeo = new THREE.BoxGeometry(geo.parameters.width*0.8, geo.parameters.height*0.8, geo.parameters.depth*0.8);
            const coreMat = new THREE.MeshBasicMaterial({ color: color, transparent: true, opacity: 0.3});
            const core = new THREE.Mesh(coreGeo, coreMat);
            mesh.add(core);

            // Spawn far away (negative Z)
            const spawnZ = camera.position.z - 80;
            const rangeX = 8; 
            const rangeY = 5;

            mesh.position.set(
                (Math.random() - 0.5) * rangeX * 2,
                (Math.random() - 0.5) * rangeY * 2,
                spawnZ
            );

            scene.add(mesh);
            obstacles.push(mesh);
        }

        function gameOver() {
            state.isPlaying = false;
            damageOverlay.style.opacity = 1;
            
            // Shake effect
            const startPos = camera.position.clone();
            let shake = 0;
            const shakeInterval = setInterval(() => {
                camera.position.x = startPos.x + (Math.random()-0.5);
                camera.position.y = startPos.y + (Math.random()-0.5);
                shake++;
                if(shake > 10) {
                    clearInterval(shakeInterval);
                    damageOverlay.style.opacity = 0;
                    showGameOverScreen();
                }
            }, 50);
        }

        function showGameOverScreen() {
            finalScoreEl.innerText = state.timeElapsed.toFixed(2);
            document.getElementById('ui-layer').classList.add('hidden');
            gameOverScreen.classList.remove('hidden');
        }

        function updateLevel() {
            const nextLevel = Math.floor(state.timeElapsed / CONFIG.levelDuration) + 1;
            if(nextLevel > state.level) {
                state.level = nextLevel;
                state.speed += CONFIG.speedMultiplier;
                levelEl.innerText = state.level;
                
                // Show message
                levelMsg.style.display = 'block';
                setTimeout(() => levelMsg.style.display = 'none', 2000);
            }
        }

        function animate() {
            if(!state.isPlaying) return;

            // 1. Player Movement (Camera)
            // Smoothing movement
            const targetX = input.x * 6; // Max move width
            const targetY = input.y * 4; // Max move height
            
            camera.position.x += (targetX - camera.position.x) * CONFIG.playerSensibility;
            camera.position.y += (targetY - camera.position.y) * CONFIG.playerSensibility;
            
            // Add slight roll based on X movement (banking effect)
            camera.rotation.z = -input.x * 0.5;

            // Move camera forward continuously? 
            // *Design choice*: We keep camera Z at 0, and move obstacles towards camera +Z.
            // But to make floor move, we simulate texture scroll or move grid.
            // Let's move Grid instead.
            
            const moveSpeed = state.speed;
            gridHelper.position.z += moveSpeed;
            if(gridHelper.position.z > 10) gridHelper.position.z = 0;
            ceilingHelper.position.z += moveSpeed;
            if(ceilingHelper.position.z > 10) ceilingHelper.position.z = 0;

            // Stars effect
            const positions = stars.geometry.attributes.position.array;
            for(let i=2; i<positions.length; i+=3) {
                positions[i] += moveSpeed * 3; // Stars move faster
                if(positions[i] > 10) positions[i] = -90;
            }
            stars.geometry.attributes.position.needsUpdate = true;


            // 2. Obstacles
            state.spawnTimer++;
            // Higher level = faster spawn rate
            const currentSpawnRate = Math.max(10, CONFIG.spawnRateBase - (state.level * 2));
            
            if(state.spawnTimer > currentSpawnRate) {
                spawnObstacle();
                state.spawnTimer = 0;
            }

            // Move & Collide Obstacles
            // Player HITBOX size
            const playerRadius = 0.5; 

            for(let i=obstacles.length-1; i>=0; i--) {
                const ob = obstacles[i];
                ob.position.z += moveSpeed; // Move towards camera
                
                // Rotate obstacle for dynamism
                ob.rotation.z += 0.02;

                // Collision Detection
                // Check if Z is crossing camera plane
                if(ob.position.z > -1 && ob.position.z < 2) {
                    // Check XY distance
                    const distXY = Math.hypot(ob.position.x - camera.position.x, ob.position.y - camera.position.y);
                    
                    // Simple collision sphere vs box approx
                    if(distXY < 1.5) { // Hit threshold
                        gameOver();
                    }
                }

                // Remove passed obstacles
                if(ob.position.z > 5) {
                    scene.remove(ob);
                    obstacles.splice(i, 1);
                }
            }

            // 3. Game Loop Stats
            state.timeElapsed += 1/60;
            scoreEl.innerText = state.timeElapsed.toFixed(2);
            updateLevel();

            renderer.render(scene, camera);
            requestAnimationFrame(animate);
        }

        // --- Event Bindings ---
        permBtn.addEventListener('click', setupGyro);
        
        document.getElementById('retry-btn').addEventListener('click', () => {
            resetGame();
            document.getElementById('ui-layer').classList.remove('hidden');
            gameOverScreen.classList.add('hidden');
            animate();
        });

        // Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>