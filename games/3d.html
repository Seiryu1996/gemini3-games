<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D World - Day/Night & Weather</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; display: block; }
        a.back-btn {
            position: absolute; top: 14px; left: 14px; z-index: 1100;
            padding: 10px 14px; border-radius: 12px;
            background: rgba(0,0,0,0.6); color: #0ff;
            border: 1px solid rgba(0,255,255,0.6);
            text-decoration: none; font-weight: 700; letter-spacing: 1px;
            box-shadow: 0 0 10px rgba(0,255,255,0.4);
        }
        a.back-btn:hover { background: rgba(0,255,255,0.12); }
        #settings-toggle {
            position: absolute; top: 14px; left: 120px; z-index: 1100;
            padding: 10px 12px; border-radius: 10px;
            background: rgba(0,0,0,0.65); color: #fff;
            border: 1px solid #666; cursor: pointer;
        }
        
        /* UIパネルのデザイン */
        #ui-panel {
            position: absolute;
            top: 60px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 20px;
            border-radius: 8px;
            width: 250px;
            z-index: 1000;
        }
        #ui-panel.hidden { display: none; }
        #panel-backdrop {
            position: fixed; inset: 0; background: rgba(0,0,0,0.45);
            z-index: 900; display: none;
        }
        #panel-backdrop.active { display: block; }
        .hidden { display: none !important; }
        .control-group { margin-bottom: 15px; }
        label { display: block; margin-bottom: 5px; font-size: 14px; }
        input[type="range"] { width: 100%; }
        button {
            background: #444; color: white; border: 1px solid #666;
            padding: 5px 10px; cursor: pointer; border-radius: 4px; margin-right: 5px;
        }
        /* 長押しでの選択や呼び出しメニューを抑止 */
        button, a, #touch-controls, #jump-btn {
            -webkit-user-select: none;
            user-select: none;
            -webkit-touch-callout: none;
        }
        button.active { background: #4a90e2; border-color: #4a90e2; }

        /* タッチ用簡易コントローラ */
        #touch-controls {
            position: absolute;
            left: 20px;
            bottom: 20px;
            display: grid;
            grid-template-columns: 60px 60px 60px;
            grid-template-rows: 60px 60px 60px;
            gap: 6px;
            opacity: 0.9;
            user-select: none;
            touch-action: none;
        }
        .touch-btn {
            background: rgba(30, 30, 30, 0.7);
            color: #fff;
            border: 1px solid #666;
            border-radius: 12px;
            font-size: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        #jump-btn {
            position: absolute;
            right: 20px;
            bottom: 30px;
            width: 90px;
            height: 90px;
            background: rgba(74, 144, 226, 0.8);
            border-radius: 50%;
            border: 2px solid #fff;
            color: #fff;
            font-size: 20px;
            font-weight: bold;
            user-select: none;
            touch-action: none;
        }
    </style>
    
    <!-- Import Maps: Three.jsの読み込み設定 -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div id="canvas-container"></div>
    <a class="back-btn" href="../index.html">← HUB</a>
    <button id="settings-toggle">環境設定</button>
    <div id="panel-backdrop"></div>

    <!-- タッチコントローラ -->
    <div id="touch-controls" aria-label="move pad">
        <div></div>
        <button class="touch-btn" id="btn-up">▲</button>
        <div></div>
        <button class="touch-btn" id="btn-left">◀</button>
        <div></div>
        <button class="touch-btn" id="btn-right">▶</button>
        <div></div>
        <button class="touch-btn" id="btn-down">▼</button>
        <div></div>
    </div>
    <button id="jump-btn">JUMP</button>

    <!-- UIパネル -->
    <div id="ui-panel">
        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:10px;">
            <h3 style="margin:0;">環境設定</h3>
            <button id="panel-close" style="background:#333; color:#fff; border:1px solid #555; border-radius:6px; padding:4px 8px;">✕</button>
        </div>
        
        <div class="control-group">
            <label>時間帯 (朝 - 昼 - 夜)</label>
            <input type="range" id="timeSlider" min="0" max="1" step="0.01" value="0.2">
            <span id="timeDisplay">昼</span>
        </div>

        <div class="control-group">
            <label>天気</label>
            <button id="btn-clear" class="active">晴れ</button>
            <button id="btn-rain">雨 + 霧</button>
        </div>

        <div class="control-group">
            <label>ミュージック</label>
            <button id="btn-music-toggle">BGM 再生</button>
        </div>

        <div class="control-group">
            <label>フィールド倍率</label>
            <div style="display:flex; align-items:center; gap:6px;">
                <button id="fieldScaleMinus">-</button>
                <input type="range" id="fieldScale" min="5" max="50" step="0.5" value="5" style="flex:1;">
                <button id="fieldScalePlus">+</button>
            </div>
            <span id="fieldScaleDisplay">5.0x</span>
        </div>
        
        <div style="font-size: 12px; color: #aaa; margin-top: 10px;">
            操作: WASD または 矢印キー<br>
            視点: マウスドラッグ
        </div>
    </div>

    <!-- メインスクリプト -->
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        // --- 設定変数 ---
        const SETTINGS = {
            avatarSpeed: 0.2,
            stagePath: './assets/stages/forest.glb',
            avatarPath: './assets/players/dragon.glb',
            useDummyStage: false       // 床を生成するかどうか
        };

        // --- グローバル変数 ---
        let scene, camera, renderer, controls;
        let avatar;
        let stageRoot;               // 現在シーンにあるフィールドのルート
        let fieldBox = new THREE.Box3(); // フィールドの境界
        let baseFieldScale = 1;      // 物体との大きさ比較から求めた基準倍率
        let fieldScaleMultiplier = 5; // UIスライダーで指定する任意倍率 (初期5倍)
        const spawnPosition = new THREE.Vector3(0, 0.5, 0);
        let avatarHalfHeight = 0.5;
        let falling = false;
        let fallVelocity = 0;
        let sunLight, ambientLight;
        let stars, rainSystem;
        let clock = new THREE.Clock();
        const raycaster = new THREE.Raycaster();
        
        // キー入力状態
        const keys = { w: false, a: false, s: false, d: false, space: false };
        let verticalVelocity = 0;
        let grounded = true;
        const jumpSpeed = 6;
        const turnLerp = 0.2;
        let audioCtx, masterGain;
        let musicPlaying = false;
        let musicInterval;
        let lastHitTime = 0;

        init();
        animate();

        function init() {
            // 1. シーンの作成
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0xdfebff, 0.002);

            // 2. カメラの作成
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 10);

            // 3. レンダラーの作成
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true; // 影を有効化
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // 4. ライティング (太陽と環境光)
            ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            sunLight = new THREE.DirectionalLight(0xffffff, 1);
            sunLight.position.set(50, 100, 50);
            sunLight.castShadow = true;
            sunLight.shadow.mapSize.width = 2048;
            sunLight.shadow.mapSize.height = 2048;
            scene.add(sunLight);

            // 5. ステージの読み込み
            loadStage();

            // 6. アバターの作成 (簡易的なBox)
            createAvatar();

            // 7. 環境エフェクト (星空・雨)
            createStars();
            createRain();

            // 8. コントロール (マウス操作)
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.rotateSpeed = 1.4; // ドラッグ感度アップ
            controls.zoomSpeed = 2.0;   // ズーム感度アップ
            controls.panSpeed = 1.2;

            // 9. イベントリスナー
            window.addEventListener('resize', onWindowResize);
            window.addEventListener('keydown', (e) => keyHandler(e, true));
            window.addEventListener('keyup', (e) => keyHandler(e, false));
            
            // UIイベント
            setupUI();
            
            // 初期状態の時間を適用
            updateTimeOfDay(0.2); // 昼
        }

        // --- ステージ読み込み ---
        function loadStage() {
            if (!SETTINGS.useDummyStage) {
                // GLBファイルを読み込む場合
                const loader = new GLTFLoader();
                loader.load(
                    SETTINGS.stagePath,
                    (gltf) => {
                        const model = gltf.scene;
                        model.traverse((child) => {
                            if (child.isMesh) {
                                child.receiveShadow = true;
                                child.castShadow = true;
                            }
                        });
                        stageRoot = model;
                        scene.add(stageRoot);
                        setupFieldBoundsAndScale();
                    },
                    undefined,
                    (error) => {
                        console.error('GLBの読み込みに失敗しました。ダミーを表示します。', error);
                        createDummyStage();
                    }
                );
            } else {
                createDummyStage();
            }
        }

        function createDummyStage() {
            stageRoot = new THREE.Group();

            // 地面 (草)
            const geometry = new THREE.PlaneGeometry(200, 200);
            const material = new THREE.MeshStandardMaterial({ color: 0x4caf50 });
            const ground = new THREE.Mesh(geometry, material);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            stageRoot.add(ground);

            // 木のようなオブジェクトをランダム配置
            const treeGeo = new THREE.ConeGeometry(1, 4, 8);
            const treeMat = new THREE.MeshStandardMaterial({ color: 0x2e7d32 });
            for (let i = 0; i < 50; i++) {
                const tree = new THREE.Mesh(treeGeo, treeMat);
                tree.position.set(
                    (Math.random() - 0.5) * 100,
                    2,
                    (Math.random() - 0.5) * 100
                );
                tree.castShadow = true;
                tree.receiveShadow = true;
                stageRoot.add(tree);
            }

            scene.add(stageRoot);
            setupFieldBoundsAndScale();
        }

        // --- アバター作成 ---
        function createAvatar() {
            const loader = new GLTFLoader();
            loader.load(
                SETTINGS.avatarPath,
                (gltf) => {
                    avatar = gltf.scene;
                    avatar.traverse((child) => {
                        if (child.isMesh) {
                            child.castShadow = true;
                            child.receiveShadow = true;
                        }
                    });
                    avatar.position.copy(spawnPosition);
                    scene.add(avatar);

                    // サイズ計測と接地
                    const size = new THREE.Box3().setFromObject(avatar).getSize(new THREE.Vector3());
                    avatarHalfHeight = size.y / 2 || 0.5;
                    placeAvatarOnGround(spawnPosition);

                    // 物体が用意できたらフィールドとのサイズ比較を更新
                    setupFieldBoundsAndScale();
                },
                undefined,
                (error) => {
                    console.error('アバターGLB読み込み失敗、デフォルトBoxを使用します', error);
                    const geometry = new THREE.BoxGeometry(1, 1, 1);
                    const material = new THREE.MeshStandardMaterial({ color: 0xff3333 });
                    avatar = new THREE.Mesh(geometry, material);
                    avatar.position.copy(spawnPosition);
                    avatar.castShadow = true;
                    scene.add(avatar);
                    avatarHalfHeight = 0.5;
                    placeAvatarOnGround(spawnPosition);
                    setupFieldBoundsAndScale();
                }
            );
        }

        // --- 星空作成 ---
        function createStars() {
            const count = 5000;
            const geometry = new THREE.BufferGeometry();
            const positions = [];
            
            for(let i = 0; i < count; i++) {
                const x = (Math.random() - 0.5) * 200;
                const y = Math.random() * 100 + 10; // 空の高い位置
                const z = (Math.random() - 0.5) * 200;
                positions.push(x, y, z);
            }
            
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            const material = new THREE.PointsMaterial({ color: 0xffffff, size: 0.2, transparent: true, opacity: 0 });
            stars = new THREE.Points(geometry, material);
            scene.add(stars);
        }

        // --- 雨作成 ---
        function createRain() {
            const count = 1500;
            const geometry = new THREE.BufferGeometry();
            const positions = [];

            for(let i = 0; i < count; i++) {
                positions.push((Math.random() - 0.5) * 100); // x
                positions.push(Math.random() * 40);          // y
                positions.push((Math.random() - 0.5) * 100); // z
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            const material = new THREE.PointsMaterial({
                color: 0xaaaaaa,
                size: 0.1,
                transparent: true,
                opacity: 0.6
            });

            rainSystem = new THREE.Points(geometry, material);
            rainSystem.visible = false; // 最初は非表示
            scene.add(rainSystem);
        }

        // --- サイズ計測 & スケール反映 ---
        function getAvatarSize() {
            return new THREE.Box3().setFromObject(avatar).getSize(new THREE.Vector3());
        }

        function getFieldSize() {
            if (!stageRoot) return new THREE.Vector3(1, 1, 1);
            return new THREE.Box3().setFromObject(stageRoot).getSize(new THREE.Vector3());
        }

        function setupFieldBoundsAndScale() {
            if (!stageRoot || !avatar) return;

            updateFieldBounds();

            const avatarSize = getAvatarSize();
            const fieldSize = getFieldSize();

            // フィールドと物体のサイズを比較して、同等サイズになるよう基準倍率を算出
            const avatarDiag = avatarSize.length();
            const fieldDiag = fieldSize.length();
            baseFieldScale = fieldDiag > 0 ? avatarDiag / fieldDiag : 1;

            applyFieldScale();
            // スケール変更後は再度地面にスナップ
            placeAvatarOnGround(avatar.position);
        }

        function updateFieldBounds() {
            if (!stageRoot) return;
            stageRoot.updateMatrixWorld(true);
            fieldBox.setFromObject(stageRoot);
        }

        function applyFieldScale() {
            if (!stageRoot) return;
            const scale = baseFieldScale * fieldScaleMultiplier;
            stageRoot.scale.setScalar(scale);
            updateFieldBounds();

            const display = document.getElementById('fieldScaleDisplay');
            if (display) display.textContent = `${fieldScaleMultiplier.toFixed(1)}x`;
            const slider = document.getElementById('fieldScale');
            if (slider && parseFloat(slider.value) !== fieldScaleMultiplier) {
                slider.value = fieldScaleMultiplier;
            }
        }

        // 前方の簡易衝突判定（ステージ上のオブジェクトに当たったら進まない）
        function canMove(moveVec) {
            if (!stageRoot || moveVec.lengthSq() === 0) return true;
            const origin = avatar.position.clone();
            origin.y += avatarHalfHeight;
            const dir = moveVec.clone().normalize();
            raycaster.set(origin, dir);
            const intersects = raycaster.intersectObject(stageRoot, true);
            if (intersects.length === 0) return true;

            const dist = intersects[0].distance;
            const clearance = avatarHalfHeight * 0.8;
            // 衝突点の高さを確認して、アバターより高い障害物なら接地時は乗り越え不可
            const hit = intersects[0];
            const groundY = getGroundHeightAt(hit.point.x, hit.point.z);
            const obstacleHeight = hit.point.y - groundY;

            // ジャンプ中はある程度通過を許可、接地時は高さ・距離両方でブロック
            if (grounded) {
                if (obstacleHeight > avatarHalfHeight * 0.95) {
                    hitBlock();
                    return false;
                }
                if (dist <= moveVec.length() + clearance) {
                    hitBlock();
                    return false;
                }
            }
            return true;
        }

        function hitBlock() {
            const now = performance.now();
            if (now - lastHitTime > 200) {
                playSfx('hit');
                lastHitTime = now;
            }
        }

        function snapTo90(dir) {
            // dir: normalized Vector3 on XZ plane
            const yaw = Math.atan2(dir.x, dir.z);
            const snappedYaw = Math.round(yaw / (Math.PI / 2)) * (Math.PI / 2);
            return new THREE.Vector3(Math.sin(snappedYaw), 0, Math.cos(snappedYaw));
        }

        function rotateAvatarToDirection(dir) {
            if (!avatar || dir.lengthSq() === 0) return;
            const yaw = Math.atan2(dir.x, dir.z);
            const targetQuat = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), yaw);
            avatar.quaternion.slerp(targetQuat, turnLerp);
        }

        // --- Audio ---
        function ensureAudio() {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                masterGain = audioCtx.createGain();
                masterGain.gain.value = 0.2;
                masterGain.connect(audioCtx.destination);
            }
        }

        function playSfx(type) {
            ensureAudio();
            if (!audioCtx) return;
            const ctx = audioCtx;
            const osc = ctx.createOscillator();
            const gain = ctx.createGain();
            const now = ctx.currentTime;
            let freq = 440;
            switch(type) {
                case 'jump': freq = 520; break;
                case 'hit': freq = 180; break;
                case 'fall': freq = 110; break;
            }
            osc.frequency.setValueAtTime(freq, now);
            gain.gain.setValueAtTime(0.0, now);
            gain.gain.linearRampToValueAtTime(0.2, now + 0.01);
            gain.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
            osc.connect(gain).connect(masterGain);
            osc.start(now);
            osc.stop(now + 0.35);
        }

        function playMusicLoop() {
            if (!audioCtx) return;
            const ctx = audioCtx;
            const tempo = 90; // bpm
            const beat = 60 / tempo;
            const pattern = [0, 4, 7, 11]; // chord tones
            const bassPattern = [0, -5, -3, -7];

            const scheduleChord = (time, chordRoot) => {
                for (let i = 0; i < 3; i++) {
                    const osc = ctx.createOscillator();
                    const gain = ctx.createGain();
                    osc.type = 'sine';
                    osc.frequency.value = 220 * Math.pow(2, (chordRoot + pattern[i]) / 12);
                    gain.gain.setValueAtTime(0.0001, time);
                    gain.gain.exponentialRampToValueAtTime(0.08, time + 0.01);
                    gain.gain.exponentialRampToValueAtTime(0.0001, time + beat * 1.8);
                    osc.connect(gain).connect(masterGain);
                    osc.start(time);
                    osc.stop(time + beat * 2);
                }

                // Bass
                const bassOsc = ctx.createOscillator();
                const bassGain = ctx.createGain();
                bassOsc.type = 'triangle';
                bassOsc.frequency.value = 110 * Math.pow(2, bassPattern[0] / 12);
                bassGain.gain.setValueAtTime(0.0001, time);
                bassGain.gain.exponentialRampToValueAtTime(0.12, time + 0.02);
                bassGain.gain.exponentialRampToValueAtTime(0.0001, time + beat * 1.9);
                bassOsc.connect(bassGain).connect(masterGain);
                bassOsc.start(time);
                bassOsc.stop(time + beat * 2);
            };

            const start = ctx.currentTime + 0.05;
            scheduleChord(start, 0);
            scheduleChord(start + beat * 2, 2);
            scheduleChord(start + beat * 4, 4);
            scheduleChord(start + beat * 6, -3);

            musicInterval = setInterval(() => {
                if (!musicPlaying) return;
                const t = ctx.currentTime + 0.05;
                scheduleChord(t, 0);
                scheduleChord(t + beat * 2, 2);
                scheduleChord(t + beat * 4, 4);
                scheduleChord(t + beat * 6, -3);
            }, beat * 8 * 1000);
        }

        // --- 毎フレームのアニメーション ---
        function animate() {
            requestAnimationFrame(animate);

            const delta = clock.getDelta();

            // 1. アバター移動処理＋簡易衝突
            if (avatar) {
                const moveSpeed = SETTINGS.avatarSpeed;

                // カメラ基準の方向ベクトル
                const forward = new THREE.Vector3();
                camera.getWorldDirection(forward);
                forward.y = 0;
                forward.normalize();
                const right = new THREE.Vector3();
                right.crossVectors(forward, new THREE.Vector3(0, 1, 0));

                const moveVec = new THREE.Vector3();
                if (keys.w || keys.ArrowUp) moveVec.add(forward);
                if (keys.s || keys.ArrowDown) moveVec.add(forward.clone().multiplyScalar(-1));
                if (keys.a || keys.ArrowLeft) moveVec.add(right.clone().multiplyScalar(-1));
                if (keys.d || keys.ArrowRight) moveVec.add(right);

                if (moveVec.lengthSq() > 0) {
                    moveVec.normalize();
                    const snappedDir = snapTo90(moveVec);
                    rotateAvatarToDirection(snappedDir);
                    const stepVec = snappedDir.clone().multiplyScalar(moveSpeed);
                    if (canMove(stepVec)) avatar.position.add(stepVec);
                }

                // ジャンプ入力
                if (!falling && grounded && keys.space) {
                    verticalVelocity = jumpSpeed;
                    grounded = false;
                    playSfx('jump');
                }

                // 重力・ジャンプ処理（フィールド内）
                if (!falling) {
                    if (!grounded) {
                        verticalVelocity -= 9.8 * delta * 2;
                        avatar.position.y += verticalVelocity * delta;
                    }

                    const groundY = getGroundHeightAt(avatar.position.x, avatar.position.z) + avatarHalfHeight;
                    if (avatar.position.y <= groundY) {
                        avatar.position.y = groundY;
                        grounded = true;
                        verticalVelocity = 0;
                    } else {
                        grounded = false;
                    }
                }

                // カメラ追従 (簡易的)
                controls.target.lerp(avatar.position, 0.1);
                controls.update();
            }

            // 1.5 フィールドとの当たり判定・落下処理
            if (stageRoot && avatar) {
                if (fieldBox.isEmpty()) updateFieldBounds();

                const insideX = avatar.position.x >= fieldBox.min.x && avatar.position.x <= fieldBox.max.x;
                const insideZ = avatar.position.z >= fieldBox.min.z && avatar.position.z <= fieldBox.max.z;
                const inside = insideX && insideZ;

                if (!inside && !falling) startFalling();
                if (inside && falling) stopFalling();

                if (falling) {
                    fallVelocity -= 9.8 * delta * 2; // 簡易重力
                    avatar.position.y += fallVelocity * delta;
                    if (avatar.position.y < -10) respawnAvatar();
                }
            }

            // 2. 雨のアニメーション
            if (rainSystem && rainSystem.visible) {
                const positions = rainSystem.geometry.attributes.position.array;
                for (let i = 1; i < positions.length; i += 3) {
                    positions[i] -= 0.3; // 落下速度
                    if (positions[i] < 0) {
                        positions[i] = 40; // 上に戻す
                    }
                }
                rainSystem.geometry.attributes.position.needsUpdate = true;
            }

            renderer.render(scene, camera);
        }

        // --- UI操作とロジック ---
        function setupUI() {
            // 時間スライダー
            const slider = document.getElementById('timeSlider');
            const display = document.getElementById('timeDisplay');
            
            slider.addEventListener('input', (e) => {
                const val = parseFloat(e.target.value);
                updateTimeOfDay(val);
                
                // 表示テキスト更新
                if (val < 0.25) display.innerText = '朝';
                else if (val < 0.75) display.innerText = '昼';
                else display.innerText = '夜';
            });

            // 天気ボタン
            document.getElementById('btn-clear').addEventListener('click', () => setWeather('clear'));
            document.getElementById('btn-rain').addEventListener('click', () => setWeather('rain'));

            // フィールド倍率スライダー
            const fieldScaleSlider = document.getElementById('fieldScale');
            const fieldScaleDisplay = document.getElementById('fieldScaleDisplay');
            fieldScaleSlider.addEventListener('input', (e) => {
                fieldScaleMultiplier = parseFloat(e.target.value);
                fieldScaleDisplay.textContent = `${fieldScaleMultiplier.toFixed(1)}x`;
                applyFieldScale();
            });

            const minusBtn = document.getElementById('fieldScaleMinus');
            const plusBtn = document.getElementById('fieldScalePlus');
            const step = parseFloat(fieldScaleSlider.step) || 0.1;
            minusBtn.addEventListener('click', () => {
                const val = Math.max(parseFloat(fieldScaleSlider.min), fieldScaleMultiplier - step);
                fieldScaleSlider.value = val;
                fieldScaleSlider.dispatchEvent(new Event('input'));
            });
            plusBtn.addEventListener('click', () => {
                const val = Math.min(parseFloat(fieldScaleSlider.max), fieldScaleMultiplier + step);
                fieldScaleSlider.value = val;
                fieldScaleSlider.dispatchEvent(new Event('input'));
            });

            // BGM toggle
            const musicBtn = document.getElementById('btn-music-toggle');
            const startMusic = () => {
                ensureAudio();
                if (musicPlaying) return;
                musicPlaying = true;
                musicBtn.textContent = 'BGM 停止';
                playMusicLoop();
            };
            const stopMusic = () => {
                musicPlaying = false;
                musicBtn.textContent = 'BGM 再生';
                if (musicInterval) clearInterval(musicInterval);
            };
            musicBtn.addEventListener('click', () => {
                if (!musicPlaying) startMusic();
                else stopMusic();
            });

            // 初回操作でオーディオを解放し自動再生
            const unlockAudio = async () => {
                ensureAudio();
                if (audioCtx.state === 'suspended') await audioCtx.resume();
                startMusic();
                window.removeEventListener('pointerdown', unlockAudio);
            };
            window.addEventListener('pointerdown', unlockAudio, { once: true });

            // 可能なら即再生（デスクトップ自動再生許可の場合）
            try {
                ensureAudio();
                audioCtx.resume().then(() => startMusic());
            } catch (e) { /* autoplay blocked; handled by unlockAudio */ }

            // モーダル開閉
            const panel = document.getElementById('ui-panel');
            const toggleBtn = document.getElementById('settings-toggle');
            const closeBtn = document.getElementById('panel-close');
            const backdrop = document.getElementById('panel-backdrop');

            const openPanel = () => {
                panel.classList.remove('hidden');
                backdrop.classList.add('active');
                toggleBtn.textContent = '設定を閉じる';
            };
            const closePanel = () => {
                panel.classList.add('hidden');
                backdrop.classList.remove('active');
                toggleBtn.textContent = '環境設定';
            };

            toggleBtn.addEventListener('click', () => {
                if (panel.classList.contains('hidden')) openPanel();
                else closePanel();
            });
            closeBtn.addEventListener('click', closePanel);
            backdrop.addEventListener('click', closePanel);

            // 初期状態: 閉じておく
            closePanel();

            // タッチボタンをキーと連動
            setupTouchButton('btn-up', 'w');
            setupTouchButton('btn-down', 's');
            setupTouchButton('btn-left', 'a');
            setupTouchButton('btn-right', 'd');
            setupTouchButton('jump-btn', 'space');
        }

        // 時間帯の変更処理 (0=朝, 0.5=昼, 1=夜 と仮定してマッピング)
        function updateTimeOfDay(value) {
            // value: 0(朝) -> 0.5(昼) -> 1(夜)
            
            // 太陽の動き (X軸中心に回転)
            // 朝(-PI/4) -> 昼(PI/2) -> 夜(PI) のように角度を計算
            const angle = (value - 0.2) * Math.PI; 
            
            const r = 100;
            sunLight.position.x = r * Math.cos(angle);
            sunLight.position.y = r * Math.sin(angle);
            sunLight.position.z = 50;

            // 背景色とライトの強さを変更
            let skyColor, groundColor, sunIntensity;

            if (value > 0.8) { 
                // 夜
                skyColor = 0x050510; 
                sunIntensity = 0;
                ambientLight.intensity = 0.1;
                stars.material.opacity = 1; // 星を表示
            } else if (value < 0.2) {
                // 夜明け前
                skyColor = 0x221133;
                sunIntensity = 0.2;
                ambientLight.intensity = 0.3;
                stars.material.opacity = 0.5;
            } else {
                // 昼間
                skyColor = 0x87ceeb;
                sunIntensity = 1;
                ambientLight.intensity = 0.6;
                stars.material.opacity = 0; // 星を消す
            }

            scene.background = new THREE.Color(skyColor);
            scene.fog.color = new THREE.Color(skyColor);
            sunLight.intensity = sunIntensity;
        }

        // 天気の変更処理
        function setWeather(type) {
            const btnClear = document.getElementById('btn-clear');
            const btnRain = document.getElementById('btn-rain');

            if (type === 'rain') {
                rainSystem.visible = true;
                scene.fog.density = 0.02; // 霧を濃く
                
                btnClear.classList.remove('active');
                btnRain.classList.add('active');
            } else {
                rainSystem.visible = false;
                scene.fog.density = 0.002; // 霧を薄く（晴れ）
                
                btnClear.classList.add('active');
                btnRain.classList.remove('active');
            }
        }

        // 落下・リスポーン制御
        function startFalling() {
            falling = true;
            grounded = false;
            verticalVelocity = 0;
            fallVelocity = 0;
            playSfx('fall');
        }

        function stopFalling() {
            falling = false;
            fallVelocity = 0;
            verticalVelocity = 0;
            placeAvatarOnGround(avatar.position);
            grounded = true;
        }

        function respawnAvatar() {
            falling = false;
            fallVelocity = 0;
            verticalVelocity = 0;
            grounded = true;
            placeAvatarOnGround(spawnPosition);
            controls.target.copy(avatar.position);
        }

        // 地面に接地させる
        function getGroundHeightAt(x, z) {
            if (!stageRoot) return 0;
            raycaster.set(new THREE.Vector3(x, 1000, z), new THREE.Vector3(0, -1, 0));
            const intersects = raycaster.intersectObject(stageRoot, true);
            if (intersects.length > 0) return intersects[0].point.y;
            return 0;
        }

        function placeAvatarOnGround(position) {
            const groundY = getGroundHeightAt(position.x, position.z);
            avatar.position.set(position.x, groundY + avatarHalfHeight, position.z);
            grounded = true;
            verticalVelocity = 0;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function keyHandler(e, isDown) {
            const k = e.key.toLowerCase();
            if (k === 'w' || k === 'arrowup') keys.w = isDown;
            if (k === 'a' || k === 'arrowleft') keys.a = isDown;
            if (k === 's' || k === 'arrowdown') keys.s = isDown;
            if (k === 'd' || k === 'arrowright') keys.d = isDown;
            if (k === ' ') keys.space = isDown;
        }

        // タッチ操作用
        function setupTouchButton(id, keyName) {
            const btn = document.getElementById(id);
            if (!btn) return;
            const setState = (state) => {
                keys[keyName] = state;
            };
            const down = (ev) => { ev.preventDefault(); setState(true); };
            const up = (ev) => { ev.preventDefault(); setState(false); };
            btn.addEventListener('pointerdown', down);
            btn.addEventListener('pointerup', up);
            btn.addEventListener('pointerleave', up);
            btn.addEventListener('pointercancel', up);
        }
    </script>
</body>
</html>
