<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>NEON SMASH AR</title>
    <style>
        /* --- CYBERPUNK / GAMING UI --- */
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Courier New', Courier, monospace; }
        video#webcam { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; object-fit: cover; z-index: 1; }
        
        #canvas-container { position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; z-index: 2; }
        #video-container { position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; z-index: 1; object-fit: cover; transform: scaleX(-1); }

        /* HUD Layer */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10; pointer-events: none;
            display: flex; flex-direction: column; justify-content: space-between;
        }

        /* Top HUD: Score & Level */
        .hud-top {
            padding: 15px; display: flex; justify-content: space-between; align-items: flex-start;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.8); color: #fff;
        }
        .score-box { font-size: 24px; font-weight: bold; color: #0ff; }
        .level-box { font-size: 20px; color: #f0f; text-align: right; }
        .sub-text { font-size: 12px; opacity: 0.8; color: #fff; }

        /* Center HUD: Timer & Messages */
        #center-msg {
            position: absolute; top: 30%; width: 100%; text-align: center;
            font-size: 40px; font-weight: 900; color: #ff0; 
            text-shadow: 2px 2px 0px #f00; display: none;
            animation: pulse 0.5s infinite alternate;
        }
        @keyframes pulse { from { transform: scale(1); } to { transform: scale(1.1); } }

        /* Bottom HUD: Progress Bar */
        .hud-bottom { padding: 20px; width: 100%; box-sizing: border-box; }
        .progress-container {
            width: 100%; height: 10px; background: rgba(255, 255, 255, 0.2);
            border: 1px solid #0ff; position: relative;
        }
        #timer-bar {
            width: 100%; height: 100%; background: #0f0; transition: width 0.1s linear;
        }
        #quota-text { text-align: center; color: #0ff; margin-bottom: 5px; font-weight: bold; }

        /* Screens */
        .screen {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.85); color: #0f0; z-index: 100;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            backdrop-filter: blur(5px);
        }
        h1 { font-size: 40px; margin: 0; text-shadow: 0 0 10px #0f0; letter-spacing: 5px; text-align: center;}
        p { font-size: 16px; color: #fff; text-align: center; max-width: 80%; }
        
        .btn {
            margin-top: 30px; padding: 15px 50px; background: transparent; 
            border: 2px solid #0f0; color: #0f0; font-size: 20px; cursor: pointer; pointer-events: auto;
            text-transform: uppercase; letter-spacing: 2px;
            box-shadow: 0 0 15px #0f0, inset 0 0 15px #0f0;
            transition: all 0.2s;
        }
        .btn:active { background: #0f0; color: #000; }
        
        .hidden { display: none !important; }

        /* Hit Effect */
        #flash {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: white; opacity: 0; pointer-events: none; z-index: 5;
            transition: opacity 0.1s;
        }

    </style>
</head>
<body>

    <!-- Camera & Canvas -->
    <video id="webcam" autoplay playsinline muted></video>
    <div id="canvas-container"></div>
    <div id="flash"></div>

    <!-- UI Overlay -->
    <div id="ui-layer" class="hidden">
        <div class="hud-top">
            <div class="score-box">SCORE: <span id="score">0</span></div>
            <div class="level-box">
                LEVEL <span id="level">1</span><br>
                <span class="sub-text">NEXT: <span id="quota">5</span> HITS</span>
            </div>
        </div>
        <div id="center-msg">LEVEL UP!</div>
        <div class="hud-bottom">
            <div id="quota-text">TIME LIMIT</div>
            <div class="progress-container">
                <div id="timer-bar"></div>
            </div>
        </div>
    </div>

    <!-- Start Screen -->
    <div id="start-screen" class="screen">
        <div class="loader" id="loader"></div>
        <h1>NEON<br>SMASH</h1>
        <p>MAKE A FIST [✊] TO BREAK BLOCKS</p>
        <p id="status-text" style="color:#666; font-size:12px; margin-top:10px;">INITIALIZING SYSTEM...</p>
        <button id="start-btn" class="btn hidden">MISSION START</button>
    </div>

    <!-- Game Over Screen -->
    <div id="game-over-screen" class="screen hidden">
        <h1 style="color:#f00; text-shadow: 0 0 10px #f00;">GAME OVER</h1>
        <p>MISSION FAILED</p>
        <p style="font-size: 24px; margin-top:20px;">FINAL SCORE: <span id="final-score">0</span></p>
        <button id="retry-btn" class="btn">RETRY</button>
    </div>

    <!-- Libraries -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { FilesetResolver, HandLandmarker } from '@mediapipe/tasks-vision';

        // --- Game State & Config ---
        const GAME_CONFIG = {
            baseTime: 15,     // 1レベルあたりの秒数
            baseQuota: 5,     // レベル1のノルマ
            spawnRate: 60,    // ブロック出現間隔(フレーム)
            speedBase: 0.05   // ブロックの基本速度
        };

        let state = {
            isPlaying: false,
            score: 0,
            level: 1,
            hitsInLevel: 0,
            quota: GAME_CONFIG.baseQuota,
            timeLeft: GAME_CONFIG.baseTime,
            spawnTimer: 0
        };

        // DOM Elements
        const videoElement = document.getElementById('webcam');
        const isMobile = /Android|iPhone|iPad|iPod/i.test(navigator.userAgent);
        const uiLayer = document.getElementById('ui-layer');
        const scoreEl = document.getElementById('score');
        const levelEl = document.getElementById('level');
        const quotaEl = document.getElementById('quota');
        const timerBar = document.getElementById('timer-bar');
        const centerMsg = document.getElementById('center-msg');
        const startScreen = document.getElementById('start-screen');
        const gameOverScreen = document.getElementById('game-over-screen');
        const finalScoreEl = document.getElementById('final-score');
        const startBtn = document.getElementById('start-btn');
        const retryBtn = document.getElementById('retry-btn');
        const statusText = document.getElementById('status-text');
        let MIRROR = true; // 起動後にカメラ種別で上書き
        let HAND_SCALE = { x: 7.0, y: 5.5 };
        let HAND_OFFSET = { x: 0, y: 0 };

        // --- Three.js Setup ---
        const scene = new THREE.Scene();
        // 背景カメラ映像が見えるように背景色を透明に
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.z = 5; 

        const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // Lights
        const light = new THREE.DirectionalLight(0xffffff, 2);
        light.position.set(2, 2, 5);
        scene.add(light);
        scene.add(new THREE.AmbientLight(0xffffff, 0.5));

        // Objects
        let blocks = [];
        let particles = [];
        
        // Hand Cursor (The Fist)
        const handGeo = new THREE.SphereGeometry(0.3, 16, 16);
        const handMat = new THREE.MeshBasicMaterial({ color: 0xff0000, wireframe: true, transparent: true, opacity: 0.5 });
        const handMesh = new THREE.Mesh(handGeo, handMat);
        scene.add(handMesh);
        handMesh.visible = false;

        // --- MediaPipe Setup ---
        let handLandmarker = undefined;
        let lastVideoTime = -1;

        const setupMediaPipe = async () => {
            const vision = await FilesetResolver.forVisionTasks(
                "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm"
            );
            handLandmarker = await HandLandmarker.createFromOptions(vision, {
                baseOptions: {
                    modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`,
                    delegate: "GPU"
                },
                runningMode: "VIDEO",
                numHands: 1
            });
            statusText.innerText = "SYSTEM READY";
            startBtn.classList.remove('hidden');
        };
        setupMediaPipe();

        // --- Game Logic Functions ---

        function initGame() {
            state = {
                isPlaying: true,
                score: 0,
                level: 1,
                hitsInLevel: 0,
                quota: GAME_CONFIG.baseQuota,
                timeLeft: GAME_CONFIG.baseTime,
                spawnTimer: 0
            };
            
            // Clear existing blocks
            blocks.forEach(b => scene.remove(b));
            blocks = [];
            
            updateUI();
            startScreen.classList.add('hidden');
            gameOverScreen.classList.add('hidden');
            uiLayer.classList.remove('hidden');
            
            // Start Camera if not running
            if (videoElement.srcObject === null) {
                startCamera();
            }
        }

        async function startCamera() {
            const preferredFacing = isMobile ? "environment" : "user";
            const constraintsList = [
                { video: { facingMode: { exact: preferredFacing }, width: 1280, height: 720 } },
                { video: { facingMode: preferredFacing, width: 1280, height: 720 } },
                { video: { facingMode: "user", width: 1280, height: 720 } }
            ];

            let lastError;
            for (const constraints of constraintsList) {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia(constraints);
                    const settings = stream.getVideoTracks()[0]?.getSettings();
                    const facing = settings?.facingMode || preferredFacing;
                    const isEnv = facing === 'environment' || facing === 'back';

                    MIRROR = !isEnv;
                    videoElement.style.transform = MIRROR ? 'scaleX(-1)' : 'none';

                    if (isMobile && isEnv) {
                        HAND_SCALE = { x: 6.0, y: 4.8 };
                        HAND_OFFSET = { x: 0, y: 0 };
                    }

                    videoElement.srcObject = stream;
                    videoElement.addEventListener("loadeddata", loop, { once: true });
                    return;
                } catch (err) {
                    lastError = err;
                }
            }

            console.error(lastError);
            alert("Camera Access Denied");
        }

        function spawnBlock() {
            // 色: レベルに応じて変化（青 -> 紫 -> 赤）
            const hue = (0.5 - (state.level * 0.05)) % 1.0; 
            const color = new THREE.Color().setHSL(hue > 0 ? hue : 0, 1, 0.5);

            const geometry = new THREE.BoxGeometry(0.8, 0.8, 0.8);
            const material = new THREE.MeshStandardMaterial({ 
                color: color, 
                roughness: 0.1, metalness: 0.8,
                emissive: color, emissiveIntensity: 0.5
            });
            
            const block = new THREE.Mesh(geometry, material);
            
            // ワイヤーフレーム追加
            const edges = new THREE.LineSegments(
                new THREE.EdgesGeometry(geometry),
                new THREE.LineBasicMaterial({ color: 0xffffff })
            );
            block.add(edges);

            // 画面の奥(Zマイナス)からランダムなXY位置に出現
            // プレイヤー位置(Z=5)に向かってくる
            block.position.set(
                (Math.random() - 0.5) * 8, // X range
                (Math.random() - 0.5) * 5, // Y range
                -10 - (Math.random() * 5)  // Z start (奥)
            );
            
            // 回転アニメーション用データ
            block.userData = { 
                rotSpeed: { x: Math.random()*0.1, y: Math.random()*0.1 },
                speed: GAME_CONFIG.speedBase + (state.level * 0.01) // レベルで速度アップ
            };

            scene.add(block);
            blocks.push(block);
        }

        function checkLevelUp() {
            if (state.hitsInLevel >= state.quota) {
                // Level Up Logic
                state.level++;
                state.hitsInLevel = 0;
                state.quota += 2; // ノルマ増加
                state.timeLeft = GAME_CONFIG.baseTime; // 時間回復
                
                // Show Message
                centerMsg.innerText = "LEVEL UP!";
                centerMsg.style.display = 'block';
                centerMsg.style.color = '#ff0';
                setTimeout(() => { centerMsg.style.display = 'none'; }, 1500);

                // Speed up visuals
                const flash = document.getElementById('flash');
                flash.style.background = '#0ff';
                flash.style.opacity = 0.3;
                setTimeout(() => flash.style.opacity = 0, 300);
            }
        }

        function gameOver() {
            state.isPlaying = false;
            finalScoreEl.innerText = state.score;
            uiLayer.classList.add('hidden');
            gameOverScreen.classList.remove('hidden');
        }

        function destroyBlock(block, index) {
            // エフェクト
            createParticles(block.position, block.material.color);
            
            // 削除処理
            scene.remove(block);
            blocks.splice(index, 1);
            
            // スコア加算
            state.score += 100 * state.level;
            state.hitsInLevel++;
            
            checkLevelUp();
            updateUI();

            // 画面フラッシュ
            const flash = document.getElementById('flash');
            flash.style.background = 'white';
            flash.style.opacity = 0.5;
            setTimeout(() => flash.style.opacity = 0, 50);
        }

        function createParticles(pos, color) {
            for(let i=0; i<10; i++) {
                const geo = new THREE.TetrahedronGeometry(0.1);
                const mat = new THREE.MeshBasicMaterial({ color: color });
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.copy(pos);
                mesh.userData = {
                    velocity: new THREE.Vector3(
                        (Math.random()-0.5), (Math.random()-0.5), (Math.random()-0.5)
                    ).multiplyScalar(0.2),
                    life: 30
                };
                scene.add(mesh);
                particles.push(mesh);
            }
        }

        function updateUI() {
            scoreEl.innerText = state.score;
            levelEl.innerText = state.level;
            quotaEl.innerText = state.quota - state.hitsInLevel;
            
            const ratio = state.timeLeft / GAME_CONFIG.baseTime;
            timerBar.style.width = (ratio * 100) + "%";
            
            if(ratio < 0.2) timerBar.style.background = '#f00'; // ピンチで赤く
            else timerBar.style.background = '#0f0';
        }

        // --- Main Loop ---
        async function loop() {
            // MediaPipe Logic
            if(videoElement.currentTime !== lastVideoTime) {
                lastVideoTime = videoElement.currentTime;
                const startTimeMs = performance.now();
                if (handLandmarker) {
                    const results = handLandmarker.detectForVideo(videoElement, startTimeMs);
                    
                    if(results.landmarks.length > 0) {
                        const lm = results.landmarks[0];
                        
                        // 1. 手の位置をThree.js座標に変換
                        // X軸はミラーリングのため反転
                        const normX = MIRROR ? (1 - lm[9].x) : lm[9].x; // 中指の付け根付近をカーソル中心に
                        const normY = lm[9].y;
                        const x = (normX * 2 - 1) * HAND_SCALE.x + HAND_OFFSET.x;
                        const y = (-(normY * 2 - 1)) * HAND_SCALE.y + HAND_OFFSET.y;
                        
                        // Z位置はカメラ手前で固定 (殴る判定用)
                        const handPos = new THREE.Vector3(x, y, 2); // 画面の手前(Z=2)あたり
                        
                        handMesh.position.copy(handPos);
                        handMesh.visible = true;

                        // 2. グー（Fist）判定
                        // 手首(0)と中指指先(12)の距離が近いかどうか
                        const wrist = lm[0];
                        const middleTip = lm[12];
                        const dist = Math.hypot(wrist.x - middleTip.x, wrist.y - middleTip.y);
                        
                        const isFist = dist < 0.15; // 閾値（握りこんでいるか）
                        
                        if(isFist) {
                            handMesh.material.color.setHex(0xff0000); // 攻撃モード赤
                            handMesh.scale.setScalar(1.2);
                        } else {
                            handMesh.material.color.setHex(0x00ff00); // 通常モード緑
                            handMesh.scale.setScalar(1.0);
                        }

                        // 3. 衝突判定 (攻撃モードかつプレイ中)
                        if(state.isPlaying && isFist) {
                            for (let i = blocks.length - 1; i >= 0; i--) {
                                const b = blocks[i];
                                // ブロックが手前(Z > -2)に来ていて、かつ手と近いか
                                if (b.position.z > -2 && handPos.distanceTo(b.position) < 1.5) {
                                    destroyBlock(b, i);
                                }
                            }
                        }
                    } else {
                        handMesh.visible = false;
                    }
                }
            }

            // Game State Logic
            if (state.isPlaying) {
                // Timer
                state.timeLeft -= 1/60; // Approx 60fps
                if (state.timeLeft <= 0) {
                    gameOver();
                }
                
                // Spawn
                state.spawnTimer++;
                const currentSpawnRate = Math.max(20, GAME_CONFIG.spawnRate - (state.level * 5)); // レベル高いほど頻度UP
                if (state.spawnTimer > currentSpawnRate) {
                    spawnBlock();
                    state.spawnTimer = 0;
                }
                
                updateUI();
            }

            // Object Updates
            // Blocks
            for (let i = blocks.length - 1; i >= 0; i--) {
                const b = blocks[i];
                b.position.z += b.userData.speed; // 手前に迫ってくる
                b.rotation.x += b.userData.rotSpeed.x;
                b.rotation.y += b.userData.rotSpeed.y;

                // 通り過ぎたら消す（ミス扱いにするかは要検討だが、今回は脱落条件を時間のみにするため単に消す）
                if (b.position.z > 5) {
                    scene.remove(b);
                    blocks.splice(i, 1);
                }
            }
            
            // Particles
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.position.add(p.userData.velocity);
                p.rotation.x += 0.1;
                p.userData.life--;
                p.scale.setScalar(p.userData.life / 30 * 0.1);
                if(p.userData.life <= 0) {
                    scene.remove(p);
                    particles.splice(i, 1);
                }
            }

            renderer.render(scene, camera);
            requestAnimationFrame(loop);
        }

        // Events
        startBtn.addEventListener('click', initGame);
        retryBtn.addEventListener('click', initGame);
        
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>
